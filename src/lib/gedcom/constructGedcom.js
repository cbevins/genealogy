/**
 * Constructs a searchable Gedcom instance from _gedcomData.js data.
 * (The _gedcomData.js file itself is generated by write_gedcomData.js from a GEDCOM text file produced by Ancestry.com or RootsMagic).
 *
 * While the existence of any specific set of GEDCOM record types is not assumed,
 * the following GEDCOM input file format rules are enforced:
 * - Every text line is a series of blank-separated fields
 * - Every text line has at least 2 fields
 * - The first field of every text line is a *level* number [0-n]
 * - If the second field is enclosed in '@' characters, it is a GEDCOM *key*, and the record *type* is then in the third field
 * - Otherwise, the second field is the GEDCOM record *type*
 * - Any fields after the record *type* field are all the record *content*
 */
import { Gedcom } from './Gedcom.js'

export function constructGedcom(_gedcomData, selectSet=null) {
    const gedcom = new Gedcom()
    for(let i=0; i<_gedcomData.length; i++) {
        const lineNo = i + 1
        const data = parseLine(_gedcomData[i], lineNo)
        if (data) {
            const [level, type, content] = data
            gedcom._addLine(lineNo, level, type, content)
        }
    }
    return gedcom
}

export function contextCounts(_gedcomData, selectSet=null) {
    const contexts = new Array(20).fill(0)
    const map = new Map()
    for(let i=0; i<_gedcomData.length; i++) {
        const lineNo = i + 1
        const data = parseLine(_gedcomData[i], lineNo)
        if (data) {
            const [level, type, content] = data
            contexts[level] = type
            const key = (contexts.slice(0,level+1)).join('-')
            if (!map.has(key)) map.set(key,0)
            map.set(key, map.get(key)+1)
        }
    }
    return map
}

export function parseLine(line, lineNo) {
    let fields = line.split(' ')
    if (fields[0] === '') return null
    if (fields.length < 2) {
        const msg = `Line ${lineNo} has just ${fields.length} fields: [${line}]`
        console.log(msg, fields)
        messages.push(msg)
        return null
    }
    // First field must be a level integer (base 0)
    const level = Number(fields[0])
    let type
    let content
    // If the second field is a @A123@ style GEDCOM key field ...
    if (fields[1][0] === '@') {
        // ... there must be a third field with the GedcomRecord *type* (like 'INDI' or 'FAM')
        if (fields.length < 3) {
            const msg = `Line ${lineNo} has a key field '${fields[1]}' but no type field`
            console.log('FATAL ERROR', msg)
            throw new Error(msg)
        }
        content = fields[1]
        type = fields[2]
    }
    // otherwise the second field is the GedcomRecord *type* and the remaining fields are the content
    else {
        type = fields[1]
        content = fields.length > 2 ? fields[2] : ''
        for(let i=3; i<fields.length; i++) content += ' ' + fields[i]
    }
    return [level, type, content]
}
